function zdot = Closed_Loop_Composite(t,z,Dynamics0)
%% Extract State Vector 
r = [z(1);z(2)];
e = [z(3);z(4)];
Theta_Tilde = [z(5);z(6);z(7);z(8);z(9);z(10);z(11);z(12);z(13)];

%% Extract gains
G = Gains();
kr = G.kr;
ke = G.ke;
Gamma = G.Gamma;
alpha = G.alpha;
beta = G.beta;

%% Desired Trajectories qd,qd_dot,qd_ddot
qd = DesiredTraj_qd(t);
qd_dot = DesiredTraj_qd_dot(t);
qd_ddot = DesiredTraj_qd_ddot(t);

%% Solving for q,qdot
q = qd - e;
q_dot = qd_dot - r + alpha*e;

%% Solving for Theta_Hat
Theta = Theta_Values();
Theta_Hat = Theta - Theta_Tilde;

%% Dynamic Matricies
D = Dynamics(q,q_dot,Theta);
M = D.M;
Minv = D.Minv;
Mdot = D.Mdot;
Vm = D.Vm;

%% Compute regressor matrix
Y = Ymatrix(q, q_dot, qd, qd_dot, qd_ddot, alpha);

%% Controller
tau = Y*Theta_Hat + kr*r + ke*e;

% Apply torque saturation
tauMax = [250; 30];
tau = max(min(tau, tauMax), -tauMax);

%% Yf
Yf = reshape(z(14:31),2,9);

% Yfdot = -beta*Yf + beta*Y;

%Initial Conditions
q0 = Dynamics0.q0;
q_dot0 = Dynamics0.q_dot0;
D0 = Initial_Dynamics(q0);
M0 = D0.M0;

Y2dot = beta*Mdot + beta*M*q_dot + beta^2*exp(-beta*t)*M0*q_dot0;
Y2dot = beta*M* + beta*Mdot*q_dot + beta^2*exp(-beta*t)*M0*qdot0;
size(Y2dot)
Yfdot = -beta*Yf + beta*Y + Y2dot;
%% uf
uf = [z(32);z(33)];

ufdot = -beta*uf + beta*tau;

%% Test Code
uf - Yf*Theta

%% CLosed Loop Dynamics
rdot = Minv*(Y*Theta - tau - Vm*r);
edot = r - alpha*e;
ThetaTildedot = -Gamma*Y'*r - Gamma*(Yf')*Yf*Theta_Tilde;


zdot = [rdot;edot;ThetaTildedot;Yfdot(:);ufdot];
end